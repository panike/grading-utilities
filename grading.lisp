(defun get-token (s sep)
  (let ((ls (length s)))
    (do ((i 0 (+ i 1)))
	((or (>= i ls)
	     (char= (char s i) sep)) (subseq s 0 i)))))

(defvar *course*)
(defvar *section*)
(defvar *semester*)
(defvar *instructor*)

(defstruct grade-record
  (name "" :type string)
  (email "" :type string)
  (num-hw 0 :type fixnum)
  (num-quizzes 0 :type fixnum)
  (num-exams 0 :type fixnum)
  (num-lec-quizzes 0 :type fixnum)
  (num-group-work 0 :type fixnum)
  (num-class-participations 0 :type fixnum)
  (hw (make-array 45 :initial-element '(0 . 0)))
  (quiz (make-array 15 :initial-element '(0 . 0)))
  (exams (make-array 6 :initial-element '(0 . 0)))
  (group-work (make-array 45 :initial-element '(0 . 0)))
  (lec-quizzes (make-array 45 :initial-element '(0 . 0)))
  (att-earned 0 :type fixnum)
  (att-poss 0 :type fixnum)
  (supp-att-earned 0 :type fixnum)
  (supp-att-poss 0 :type fixnum))

(defmacro copy-cell (x)
  `(cons (car ,x) (cdr ,x)))

(defun drop-two (arr &optional len)
  (if (not len)
      (setf len (length arr)))
  (let ((drop-arr (let ((new-arr (sort (make-array len
						   :initial-contents
						   (subseq arr 0 len))
				       #'(lambda (x y)
					   (< (* (car x) (cdr y))
					      (* (car y) (cdr x)))))))
		    (list (copy-cell (aref new-arr 0))
			  (copy-cell (aref new-arr 1))))))
    (dolist (l drop-arr)
      (let ((x (car l))
	    (y (cdr l)))
	(dotimes (i (length arr))
	  (if (and (= x (car (aref arr i)))
		   (= y (cdr (aref arr i)))
		   (>= x 0))
	      (progn (setf (car (aref arr i)) (- x 40))
		     (setf x -100))))))))

(defun extract-drop-arr (arr n len)
  (let ((new-arr (sort (make-array len
				   :initial-contents
				   (subseq arr 0 len))
                       #'(lambda (x y)
			   (if (= (cdr x) 0)
			       nil
			       (<= (* (car x) (cdr y))
				   (* (car y) (cdr x)))))))
	(listl nil))
    (dotimes (i n)
      (setf listl (cons (copy-cell (aref new-arr i)) listl)))
    listl))

(defun drop-n (arr n &optional len)
  (if (not len)
      (setf len (length arr)))
  (let ((drop-arr (extract-drop-arr arr n len)))
    (dolist (l drop-arr)
      (let ((x (car l))
	    (y (cdr l)))
	(dotimes (i (length arr))
	  (if (and (= x (car (aref arr i)))
		   (= y (cdr (aref arr i)))
		   (>= x 0))
	      (progn (setf (car (aref arr i)) (- x 1000))
		     (setf x -100))))))))


(defmacro add-creator (funname record-accessor num-accessor)
  `(defun ,funname (gr earned poss)
     (setf (aref (,record-accessor gr) (,num-accessor gr))
	   (cons earned poss))
     (incf (,num-accessor gr))))

(defun add-att (gr earned poss)
  (setf (grade-record-att-earned gr) (+ (grade-record-att-earned gr) earned))
  (setf (grade-record-att-poss gr) (+ (grade-record-att-poss gr) poss)))

(defun add-supp-att (gr earned poss)
  (setf (grade-record-supp-att-earned gr)
	(+ (grade-record-supp-att-earned gr) earned))
  (setf (grade-record-supp-att-poss gr)
	(+ (grade-record-supp-att-poss gr) poss)))

(add-creator add-hw grade-record-hw grade-record-num-hw)
(add-creator add-quiz grade-record-quiz grade-record-num-quizzes)
(add-creator add-exam grade-record-exams grade-record-num-exams)
(add-creator add-group-work grade-record-group-work grade-record-num-group-work)
(add-creator add-lec-quiz grade-record-lec-quizzes grade-record-num-lec-quizzes)

(defun add-class-participation (gr)
  (incf (grade-record-num-class-participations gr)))

(let ((num 0))
  (defun incit ()
    (setf num (+ 1 num)))
  (defun getit () num)
  (defun resetit ()
    (setf num 0)))

(defun insert-name (s arr &optional (email ""))
  (setf (aref arr (getit)) (make-grade-record :name s :email email))
  (incit))

(defun find-name (s arr)
  (let ((right (- (length arr) 1))
	(left 0)
	(mid (floor (length arr) 2)))
    (do ((i (grade-record-name (aref arr mid))
	    (grade-record-name (aref arr mid))))
	((string= i s) mid)
      (if (< left right)
	  (if (string< s i)
	      (progn (setf right (- mid 1))
		     (setf mid (floor (+ left right) 2)))
	      (progn (setf left (+ mid 1))
		     (setf mid (floor (+ left right) 2))))
	  (return-from find-name nil)))))

(defmacro accum (gr num-fn arr-fn &optional (check-neg nil) (do-cdr nil)
		 (drop nil) (num-to-drop 2))
  (let ((x (gensym))
	(num (gensym))
	(arr (gensym))
	(i (gensym))
	(y (gensym)))
    `(let ((,x 0)
	   (,num (,num-fn ,gr))
	   (,arr (,arr-fn ,gr)))
       (if ,drop
	   (drop-n ,arr ,num-to-drop ,num))
       (do ((,i 0 (+ ,i 1)))
	   ((>= ,i ,num) ,x)
	 (setf ,x (+ ,x (if ,do-cdr
			    (cdr (aref ,arr ,i))
			    (if ,check-neg
				(let ((,y (car (aref ,arr ,i))))
				  (if (< ,y 0)
				      (+ ,y 1000) ;; (- ,y)
				      ,y))
				(car (aref ,arr ,i))))))))))

(defun accum-hw-poss (gr)
  (accum gr grade-record-num-hw grade-record-hw nil t))

(defun accum-hw-earned (gr)
  (accum gr grade-record-num-hw grade-record-hw t nil))

(defun accum-quiz-poss (gr)
  (accum gr grade-record-num-quizzes grade-record-quiz nil t))

(defun accum-quiz-earned (gr)
  (accum gr grade-record-num-quizzes grade-record-quiz t nil))

(defun accum-exam-poss (gr)
  (accum gr grade-record-num-exams grade-record-exams nil t))

(defun accum-exam-earned (gr)
  (accum gr grade-record-num-exams grade-record-exams))

(defun accum-lec-quiz-poss (gr)
  (accum gr grade-record-num-lec-quizzes grade-record-lec-quizzes nil t))

(defun accum-lec-quiz-earned (gr)
  (accum gr grade-record-num-lec-quizzes grade-record-lec-quizzes t nil))

(defun accum-group-work-poss (gr)
  (accum gr grade-record-num-group-work grade-record-group-work nil t))

(defun accum-group-work-earned (gr)
  (accum gr grade-record-num-group-work grade-record-group-work t nil))

(defun accum-hw (gr)
  (if (= 0 (accum-hw-poss gr))
      1
      (/ (accum-hw-earned gr)
	 (accum-hw-poss gr))))

(defun accum-quiz (gr)
  (if (= 0 (accum-quiz-poss gr))
      1
      (/ (accum-quiz-earned gr)
	 (accum-quiz-poss gr))))

(defun accum-lec-quiz (gr)
  (ceiling (* 20 (if (= 0 (accum-lec-quiz-poss gr))
		     1
		     (/ (accum-lec-quiz-earned gr)
			(accum-lec-quiz-poss gr))))))

(defun accum-group-work (gr)
  (if (= 0 (accum-group-work-poss gr))
      1
      (/ (accum-group-work-earned gr)
	 (accum-group-work-poss gr))))

(defun fix-att (gr)
  (if (> (grade-record-att-earned gr) (grade-record-att-poss gr))
      (setf (grade-record-att-earned gr) (grade-record-att-poss gr))))

(defun accum-att (gr)
  (fix-att gr)
  (if (= 0 (grade-record-att-poss gr))
      1
      (/ (grade-record-att-earned gr) (grade-record-att-poss gr))))

(defun accum-exam (gr)
  (accum-exam-earned gr))

(defun accum-section-scores (gr)
  (ceiling (+ (* 75 (accum-quiz gr))
	      (* 25 (accum-hw gr)))))

(defun grade-accum (gr)
  (+ (accum-exam gr)
     (accum-section-scores gr)))

(defmacro get-max-from-array (arr fn)
  (let ((x (gensym))
	(y (gensym))
	(i (gensym))
	(len (gensym)))
    `(let ((,x (,fn (aref ,arr 0)))
	   (,len (length ,arr)))
       (do ((,i 1 (+ ,i 1)))
	   ((>= ,i ,len) ,x)
	 (let ((,y (,fn (aref ,arr ,i))))
	   (if (> ,y ,x)
	       (setf ,x ,y)))))))

(defun get-max-hw (arr)
  (get-max-from-array arr grade-record-num-hw))

(defun get-max-quiz (arr)
  (get-max-from-array arr grade-record-num-quizzes))

(defun get-max-exam (arr)
  (get-max-from-array arr grade-record-num-exams))

(defun output-hw-personal-tex (gr)
  (format t "&\\ ~A\\ \\hfil&" (grade-record-name gr))
  (dotimes (i (grade-record-num-hw gr))
    (let ((y (car (aref (grade-record-hw gr) i))))
      (if (< y 0)
	  (format t "&\\ \\dored{~A}\\ &" (- y))
	  (if (= y 0)
	      (format t "&&")
	      (format t "&\\ ~A\\ &" y)))))
  (format t "&\\ ~A/~A\\ &" (accum-hw-earned gr) (accum-hw-poss gr))
  (format t "\\cr~%\\noalign{\\hrule}~%"))

(defun output-condensed-hw-tex (gr)
  (dotimes (i (grade-record-num-hw gr))
    (let ((y (car (aref (grade-record-hw gr) i))))
      (if (< y 0)
	  (format t "&\\ \\dored{~A}\\ &" (+ y 1000))
	  (format t "&\\ ~A\\ &" y))))
  (format t "&\\ ~A/~A\\ &" (accum-hw-earned gr) (accum-hw-poss gr)))

(defvar *use-newsletter* nil)

(defun start-table ()
  (format t "\\halign{&\\vrule#&\\strut#\\cr~%"))

(defun end-table () (format t "}~%"))

(defmacro output-header (accessor arr heading)
  (let ((i (gensym)))
    `(progn (format t "\\omit\\span\\omit\\span")
	    (dotimes (,i (,accessor (aref ,arr 0)))
	      (format t "\\omit\\span\\omit\\span"))
	    (format t "\\omit\\span\\omit\\span\\omit")
	    (format t "\\hss\\bf ~A\\hss\\cr~%" ,heading)
	    (format t "\\noalign{\\vskip\\smallskipamount}~%")
	    (format t "\\noalign{\\hrule}~%"))))

(defun output-hw-tex (arr)
  (declare (special *use-newsletter*))
  (if *use-newsletter*
      (format t "\\beginarticle\\hsize{Homework}~%"))
  (start-table)
  (output-header grade-record-num-hw arr "Homework")
  (do ((i 0 (+ i 1)))
      ((>= i (length arr)) nil)
    (output-hw-personal-tex (aref arr i)))
  (end-table)
  (if *use-newsletter*
      (format t "\\endarticle~%")
      (format t "\\vfil\\eject~%")))

(defun output-quiz-personal-tex (gr)
  (format t "&\\ ~A\\ \\hfil&" (grade-record-name gr))
  (dotimes (i (grade-record-num-quizzes gr))
    (let ((y (car (aref (grade-record-quiz gr) i))))
      (if (< y 0)
	  (format t "&\\ \\dored{~A}\\ &" (- y))
	  (format t "&\\ ~A\\ &" y))))
  (format t "&\\ ~A/~A\\ &" (accum-quiz-earned gr) (accum-quiz-poss gr))
  (format t "\\cr~%\\noalign{\\hrule}~%"))

(defun output-condensed-quiz-tex (gr)
  (dotimes (i (grade-record-num-quizzes gr))
    (let ((y (car (aref (grade-record-quiz gr) i))))
      (if (< y 0)
	  (format t "&\\ \\dored{~A}\\ &" (+ y 1000))
	  (format t "&\\ ~A\\ &" y))))
  (format t "&\\ ~A/~A\\ &" (accum-quiz-earned gr) (accum-quiz-poss gr)))

(defun output-condensed-lec-quiz-tex (gr)
  (format t "&\\ ~A\\ &" (accum-lec-quiz gr)))

(defun output-condensed-group-work-tex (gr)
  (dotimes (i (grade-record-num-group-work gr))
    (let ((y (car (aref (grade-record-group-work gr) i))))
      (if (< y 0)
	  (format t "&\\ \\dored{~A}\\ &" (+ y 1000))
	  (format t "&\\ ~A\\ &" y))))
  (format t "&\\ ~A/~A\\ &" (accum-group-work-earned gr)
	  (accum-group-work-poss gr)))

(defun output-quiz-tex (arr)
  (declare (special *use-newsletter*))
  (if *use-newsletter*
      (format t "\\beginarticle\\hsize{Quizzes}~%"))
  (start-table)
  (output-header grade-record-num-quizzes arr "Quizzes")
  (do ((i 0 (+ i 1)))
      ((>= i (length arr)) nil)
    (output-quiz-personal-tex (aref arr i)))
  (end-table)
  (if *use-newsletter*
      (format t "\\endarticle~%")
      (format t "\\vfil\\eject~%")))

(defun output-att-personal-tex (gr)
  (fix-att gr)
  (format t "&\\ ~A\\ \\hfil&" (grade-record-name gr))
  (format t "&\\ ~A/~A\\ &" (grade-record-att-earned gr)
	  (grade-record-att-poss gr))
  (format t "\\cr~%\\noalign{\\hrule}~%"))

(defun output-condensed-att-tex (gr)
  (fix-att gr)
  (format t "&\\ ~A/~A\\ &" (grade-record-att-earned gr)
	  (grade-record-att-poss gr)))

(defun output-condensed-section-tex (gr)
  (format t "&\\ ~A\\ &" (accum-section-scores gr)))

(defun output-att-tex (arr)
  (declare (special *use-newsletter*))
  (if *use-newsletter*
      (format t "\\beginarticle\\hsize{Attendance}~%"))
  (start-table)
  (format t "\\omit\\span\\omit\\span\\omit\\span\\omit\\span\\omit")
  (format t "\\hss\\bf Attendance\\hss\\cr~%")
  (format t "\\noalign{\\vskip\\smallskipamount}~%")
  (format t "\\noalign{\\hrule}~%")
  (do ((i 0 (+ i 1)))
      ((>= i (length arr)) nil)
    (output-att-personal-tex (aref arr i)))
  (end-table)
  (if *use-newsletter*
      (format t "\\endarticle~%")
      (format t "\\vfil\\eject~%")))

(defun output-exam-personal-tex (gr)
  (format t "&\\ ~A\\ \\hfil&" (grade-record-name gr))
  (do ((i 0 (+ i 1)))
      ((>= i (grade-record-num-exams gr)) nil)
    (format t "&\\ ~A\\ &" (car (aref (grade-record-exams gr) i))))
  (format t "&\\ ~A/~A\\ &" (accum-exam-earned gr) (accum-exam-poss gr))
  (format t "\\cr~%\\noalign{\\hrule}~%"))

(defun output-condensed-exam-tex (gr)
  (do ((i 0 (+ i 1)))
      ((>= i (grade-record-num-exams gr)) nil)
    (format t "&\\ ~A\\ &" (car (aref (grade-record-exams gr) i))))
  (format t "&\\ ~A/~A\\ &" (accum-exam-earned gr) (accum-exam-poss gr)))

(defun output-exam-tex (arr)
  (declare (special *use-newsletter*))
  (if *use-newsletter*
      (format t "\\beginarticle\\hsize{Exams}~%"))
  (start-table)
  (output-header grade-record-num-exams arr "Exams")
  (do ((i 0 (+ i 1)))
      ((>= i (length arr)) nil)
    (output-exam-personal-tex (aref arr i)))
  (end-table)
  (if *use-newsletter*
      (format t "\\endarticle~%")
      (format t "\\vfil\\eject~%")))

(defun output-comprehensive-personal-tex (gr)
  (format t "&\\ ~A\\ \\hfil&&\\ ~A\\ &\\cr\\noalign{\\hrule}~%"
	  (grade-record-name gr)
	  (grade-accum gr)))

(defun output-condensed-comprehensive-tex (gr)
  (format t "&\\ ~A\\ &"
	  (grade-accum gr)))

(defun output-comprehensive-tex (arr)
  (declare (special *use-newsletter*))
  (if *use-newsletter*
      (format t "\\beginarticle\\hsize{Comprehensive}~%"))
  (start-table)
  (format t "\\omit\\span\\omit\\span\\omit\\span\\omit\\span\\omit")
  (format t "\\hss\\bf Comprehensive\\hss\\cr~%")
  (format t "\\noalign{\\vskip\\smallskipamount}~%")
  (format t "\\noalign{\\hrule}~%")
  (do ((i 0 (+ i 1)))
      ((>= i (length arr)) nil)
    (output-comprehensive-personal-tex (aref arr i)))
  (end-table)
  (if *use-newsletter*
      (format t "\\endarticle~%")
      (format t "\\vfil\\eject~%")))

(defun maximize-benefit (arr)
  (let ((len (length arr))
	(x 0)
	(ix 0))
    (do ((i 0 (+ i 1)))
	((>= i len) (values x ix))
      (let ((earned (car (aref arr i)))
	    (poss (cdr (aref arr i))))
	(if (and (>= earned 0) (< x (- poss earned)))
	    (progn (setf x (- poss earned))
		   (setf ix i)))))))

(defun insert-class-participation (gr)
  (do ((i 0 (+ i 1)))
      ((>= i (grade-record-num-class-participations gr)) nil)
    (multiple-value-bind (x ix) (maximize-benefit (grade-record-hw gr))
      (multiple-value-bind (y iy) (maximize-benefit (grade-record-quiz gr))
	(let ((zx (if (= 0 (accum-hw-poss gr))
		      0
		      (/ x (accum-hw-poss gr) 3/4)))
	      (zy (if (= 0 (accum-quiz-poss gr))
		      0
		      (/ y (accum-quiz-poss gr) 1/4))))
	      (if (> zx zy)
		  (setf (car (aref (grade-record-hw gr) ix))
			(- (cdr (aref (grade-record-hw gr) ix)) 1000))
		  (setf (car (aref (grade-record-quiz gr) iy))
			(- (cdr (aref (grade-record-quiz gr) iy)) 1000)))))))
  (setf (grade-record-num-class-participations gr) 0))

(defun do-all-class-participations (arr)
  (do ((i 0 (+ i 1)))
      ((>= i (length arr)) nil)
    (insert-class-participation (aref arr i))))

(defparameter *tex-header-output* nil)

(defun output-tex (arr &optional (do-sort t))
  (declare (special *tex-header-output*
		    *course*
		    *section*
		    *semester*
		    *instructor*
		    *use-newsletter*))
  (do-all-class-participations arr)
  (if (not *tex-header-output*)
      (progn (if *use-newsletter*
		 (format t "\\input newsmac~%"))
	     (format t "\\footline{\\hfil}~%\\offinterlineskip~%")
	     (format t "\\hsize9in \\vsize6.5in~%")
	     (format t "\\def\\dored#1{\\special{ps: 1 0 0 setrgbcolor}#1")
	     (format t "\\special{ps: 0 setgray}}~%")
	     (setf *tex-header-output* t)))
  (if *use-newsletter*
      (format t "\\beginarticle\\hsize{Header}~%"))
  (format t "\\centerline{{\\bf Course}: ~A {\\bf Section}: ~A"
	  *course* *section*)
  (format t " {\\bf Semester}: ~A {\\bf Instructor}: ~A}~%\\medskip"
	  *semester* *instructor*)
  (if *use-newsletter*
      (format t "\\endarticle~%"))
  (output-hw-tex arr)
  (output-quiz-tex arr)
  ;;  (sort arr #'(lambda (x y) (> (accum-exam-earned x)
  ;; (accum-exam-earned y))))
  (output-exam-tex arr)
  ;;  (output-att-tex arr)
  (if do-sort
      (sort arr  #'(lambda (x y) (> (grade-accum x) (grade-accum y)))))
  (output-comprehensive-tex arr)
  (format t  "\\bye~%"))

(defmacro doarr ((i arr) &rest body)
  (let ((j (gensym))
	(k (gensym)))
    `(let ((,j (length ,arr))
	   (,i nil))
       (dotimes (,k ,j)
	 (progn (setf ,i (aref ,arr ,k))
		(progn ,@body))))))

(defun produce-supp-att (arr)
  (doarr (gr arr)
	 (format t "~A ~A/~A~%" (grade-record-name gr)
		 (grade-record-supp-att-earned gr)
		 (grade-record-supp-att-poss gr))))

(defmacro create-tex-table (arr &rest headings)
  (let ((i (gensym))
	(j (gensym))
	(header (gensym))
	(count-fn (gensym))
	(gr (gensym))
	(data-fn (gensym)))
    `(progn (start-table)
	    (format t "\\noalign{\\hrule}~%")
	    (format t "&\\hfil\\bf Name\\hfil&")
	    (dolist (,i (list ,@headings))
	      (destructuring-bind (,header ,count-fn ,data-fn) ,i
		(declare (ignore ,data-fn))
		(format t "&")
		(if ,count-fn
		    (progn (dotimes (,j (funcall ,count-fn (aref ,arr 0)))
			     (format t "\\omit\\span\\omit\\span"))
			   (format t "\\omit")))
		(format t "\\hfil\\ \\bf ~A\\ \\hfil&" ,header)))
	    (format t "\\cr~%")
	    (format t "\\noalign{\\hrule\\vfil\\penalty-150\\vfilneg}~%")
	    (doarr (,gr ,arr)
		   (format t "\\noalign{\\vskip-26214sp\\hrule}")
		   (format t "&\\ ~A\\ \\hfil&" (grade-record-name ,gr))
		   (dolist (,i (list ,@headings))
		     (destructuring-bind (,header ,count-fn ,data-fn) ,i
		       (declare (ignore ,count-fn ,header))
		       (funcall ,data-fn ,gr)))
		   (format t "\\cr\\noalign{\\hrule\\vfil")
		   (format t "\\penalty-150\\vfilneg}~%"))
	    (end-table))))

(defun output-condensed-tex (arr &optional (do-sort t))
  (declare (special *tex-header-output*
		    *course*
		    *section*
		    *semester*
		    *instructor*))
  (do-all-class-participations arr)
  (if do-sort
      (sort arr  #'(lambda (x y) (> (grade-accum x) (grade-accum y)))))
  (if (not *tex-header-output*)
      (progn (format t "\\footline{\\hfil}~%\\offinterlineskip~%")
	     (format t "\\hsize9in \\vsize6.5in~%")
	     (format t "\\def\\dored#1{\\special{ps: 1 0 0 setrgbcolor}#1")
	     (format t "\\special{ps: 0 setgray}}~%")
	     (setf *tex-header-output* t)))
  (format t "\\centerline{{\\bf Course}: ~A {\\bf Section}: ~A"
	  *course* *section*)
  (format t " {\\bf Semester}: ~A {\\bf Instructor}: ~A}~%\\medskip"
	  *semester* *instructor*)
  (create-tex-table arr
		`("Comp." nil ,#'output-condensed-comprehensive-tex)
		`("Exams" ,#'grade-record-num-exams ,#'output-condensed-exam-tex)
		`("Section" nil ,#'output-condensed-section-tex)
		`("Homework" ,#'grade-record-num-hw ,#'output-condensed-hw-tex)
		`("Quizzes" ,#'grade-record-num-quizzes ,#'output-condensed-quiz-tex)
;;		`("Lecture quizzes" ,#'grade-record-num-lec-quizzes ,#'output-condensed-lec-quiz-tex)
;;		`("Group work" ,#'grade-record-num-group-work ,#'output-condensed-group-work-tex)
		`("Att." nil ,#'output-condensed-att-tex))
  (format t  "\\bye~%"))

(defun output-split-condensed-tex (arr &optional (do-sort t))
  (declare (special *tex-header-output*
		    *course*
		    *section*
		    *semester*
		    *instructor*))
  (do-all-class-participations arr)
  (if do-sort
      (sort arr  #'(lambda (x y) (> (grade-accum x) (grade-accum y)))))
  (if (not *tex-header-output*)
      (progn (format t "\\footline{\\hfil}~%\\offinterlineskip~%")
	     (format t "\\hsize9in \\vsize6.5in~%")
	     (format t "\\def\\dored#1{\\special{ps: 1 0 0 setrgbcolor}#1")
	     (format t "\\special{ps: 0 setgray}}~%")
	     (setf *tex-header-output* t)))
  (format t "\\centerline{{\\bf Course}: ~A {\\bf Section}: ~A"
	  *course* *section*)
  (format t " {\\bf Semester}: ~A {\\bf Instructor}: ~A}~%\\medskip"
	  *semester* *instructor*)
  (create-tex-table arr
		`("Comp." nil ,#'output-condensed-comprehensive-tex)
		`("Exams" ,#'grade-record-num-exams ,#'output-condensed-exam-tex)
		`("Section" nil ,#'output-condensed-section-tex)
;;		`("Lecture quizzes" ,#'grade-record-num-lec-quizzes ,#'output-condensed-lec-quiz-tex)
		`("Quizzes" ,#'grade-record-num-quizzes ,#'output-condensed-quiz-tex))
  (format t "\\bigskip~%")
  (create-tex-table arr
		`("Homework" ,#'grade-record-num-hw ,#'output-condensed-hw-tex)
;;		`("Group work" ,#'grade-record-num-group-work ,#'output-condensed-group-work-tex)
		`("Att." nil ,#'output-condensed-att-tex)
		)
  (format t  "\\bye~%"))

(defun output-personal-tex (gr &optional (s *standard-output*))
  (format s "\\footline{\\hfil}~%\\centerline{\\bf Grades for ~A}~%\\bigskip~%"
	  (grade-record-name gr))
  (format s "\\def\\dored#1{\\special{ps: 1 0 0 setrgbcolor}#1")
  (format s "\\special{ps: 0 setgray}}~%")
  (insert-class-participation gr)
  (dotimes (i (grade-record-num-hw gr))
    (progn (format s "~%{\\bf Homework ~A}: " (+ i 1))
	   (let ((z (car (aref (grade-record-hw gr) i))))
	     (if (< z 0)
		 (format s "\\dored{~A}" (- z))
		 (format s "~A" z)))
	   (format s "/~A~%" (cdr (aref (grade-record-hw gr) i)))))
  (dotimes (i (grade-record-num-quizzes gr))
    (progn (format s "~%{\\bf Quiz ~A}: " (+ i 1))
	   (let ((z (car (aref (grade-record-quiz gr) i))))
	     (if (< z 0)
		 (format s "\\dored{~A}" (- z))
		 (format s "~A" z)))
	   (format s "/~A~%" (cdr (aref (grade-record-quiz gr) i)))))
  (fix-att gr)
  (format s "~%{\\bf Attendance}: ~A/~A~%" (grade-record-att-earned gr)
	  (grade-record-att-poss gr))
  (format s "~%{\\bf Section grade}: ~A~%" (accum-section-scores gr))
  (dotimes (i (grade-record-num-exams gr))
    (format s "~%{\\bf Exam ~A}: ~A/~A~%" (+ i 1)
	    (car (aref (grade-record-exams gr) i))
	    (cdr (aref (grade-record-exams gr) i))))
  (format s "~%{\\bf Comprehensive score}: ~A~%" (grade-accum gr))
  (format s "~%\\bye~%"))

(defun output-personal-text (gr &optional (s *standard-output*))
  (if (< 2 (- (grade-record-att-poss gr) (grade-record-att-earned gr)))
	(format s "You are only allowed two absences in WES.  Please come and see me as soon as possible to arrange make-up work for your absences.~%~%")):w
  (format s "Grades for ~A~%~%" (grade-record-name gr))
  (if (< 0 (grade-record-num-class-participations gr))
      (progn (format s "{} indicates grade has been replaced ")
	     (format s "due to class participation~%~%")))
  (insert-class-participation gr)
  (grade-accum gr)
  (dotimes (i (grade-record-num-hw gr))
    (progn (format s "Homework ~A: " (+ i 1))
	   (let ((z (car (aref (grade-record-hw gr) i))))
	     (if (< z 0)
		 (format s "{~A}" (+ z 1000))
		 (format s "~A" z)))
	   (format s "/~A~%" (cdr (aref (grade-record-hw gr) i)))))
  (format s "Homework grade: ~A/~A~%" (accum-hw-earned gr) (accum-hw-poss gr))
  (dotimes (i (grade-record-num-quizzes gr))
    (progn (format s "Quiz ~A: " (+ i 1))
	   (let ((z (car (aref (grade-record-quiz gr) i))))
	     (if (< z 0)
		 (format s "{~A}" (+ z 1000))
		 (format s "~A" z)))
	   (format s "/~A~%" (cdr (aref (grade-record-quiz gr) i)))))
  (format s "Quiz grade: ~A/~A~%" (accum-quiz-earned gr) (accum-quiz-poss gr))
;;  (dotimes (i (grade-record-num-lec-quizzes gr))
;;    (progn (format s "Lecture quiz ~A: " (+ i 1))
;;	   (let ((z (car (aref (grade-record-lec-quizzes gr) i))))
;;	     (if (< z 0)
;;		 (format s "{~A}" (+ z 1000))
;;		 (format s "~A" z)))
;;	   (format s "/~A~%" (cdr (aref (grade-record-lec-quizzes gr) i)))))
;;  (format s "Lecture quiz grade: ~A/~A~%" (accum-lec-quiz-earned gr)
;;	  (accum-lec-quiz-poss gr))
;;  (format s "Lecture quiz grade: ~A~%" (accum-lec-quiz gr))
;;  (dotimes (i (grade-record-num-group-work gr))
;;    (progn (format s "Group work ~A: " (+ i 1))
;;	   (let ((z (car (aref (grade-record-group-work gr) i))))
;;	     (if (< z 0)
;;		 (format s "{~A}" (+ z 1000))
;;		 (format s "~A" z)))
;;	   (format s "/~A~%" (cdr (aref (grade-record-group-work gr) i)))))
;;  (format s "Group work grade: ~A/~A~%" (accum-group-work-earned gr)
;;	  (accum-group-work-poss gr))
  (fix-att gr)
  (format s "Attendance: ~A/~A~%" (grade-record-att-earned gr)
          (grade-record-att-poss gr))
  (format s "Section grade: ~A~%" (accum-section-scores gr))
  (dotimes (i (grade-record-num-exams gr))
    (format s "Exam ~A: ~A/~A~%" (+ i 1)
	    (car (aref (grade-record-exams gr) i))
	    (cdr (aref (grade-record-exams gr) i))))
  (format s "Exam grade: ~A/~A~%" (accum-exam-earned gr) (accum-exam-poss gr))
  (format s "Comprehensive score: ~A~%" (grade-accum gr))
  (if (> (grade-record-supp-att-poss gr) 0)
      (format s "Supplemental section attendance: ~A/~A~%"
	      (grade-record-supp-att-earned gr)
              (grade-record-supp-att-poss gr))))

(defun dump-for-student-notification (&rest arrl)
  (dolist (arr arrl)
    (dotimes (i (length arr))
      (let ((gr (aref arr i)))
	(let ((email (grade-record-email gr)))
	  (if (not (string= "" email))
	      (with-open-file (s email :direction :output :if-exists :supersede)
		(output-personal-text gr s))
	      (output-personal-text gr)))))))

(defun dump-tex-for-student-notification (&rest arrl)
  (dolist (arr arrl)
    (dotimes (i (length arr))
      (let ((gr (aref arr i)))
	(let ((filename (concatenate 'string (get-token (grade-record-email gr)
							#\@) ".tex")))
	  (if (not (string= "" filename))
	      (with-open-file
		  (s filename :direction :output :if-exists :supersede)
		(output-personal-tex gr s))
	      (output-personal-text gr)))))))

(defun compute-attendance-global (arr)
  (let ((x 0)
	(y 0))
    (doarr (gr arr)
	   (progn (setf x (+ x (grade-record-att-earned gr)))
		  (setf y (+ y (grade-record-att-poss gr)))))
    (list x y)))

(defun get-num-rows (n c)
  (let ((r (rem n c)))
    (+ (floor n c) (if (> r 0) 1 0))))

(defun create-table (num cols)
  (format t "<html>~%<head>~%<title>Worksheets for Math 222, Section 355, Spring 2010 UW-Madison</title>~%")
  (format t "</head>~%<body>~%")
  (format t "<table width=\"100%\">~%")
  (let ((num-rows (get-num-rows num cols)))
    (do ((i 1 (+ i 1)))
	((> i num-rows) nil)
      (progn (format t "<tr>~%")
	     (do ((j i (+ j num-rows))
		  (k 1 (+ k 1)))
		 ((> k cols) nil)
	       (progn (format t "<td>")
		      (if (<= j num)
			  (progn (format t "<a href=\"panike-222-s10-~2,'0,,D.pdf\">Worksheet ~D</a> " j j)
                                 (format t "<a href=\"sol-s10-~2,'0,,D.pdf\">Solutions</a>" j)))
		      (format t "</td>~%")))
	     (format t "</tr>~%"))))
  (format t "</table>~%</body>~%</html>~%"))

(defmacro csv-header-entry (s i)
  `(format t ,s (+ ,i 1)))

(defmacro csv-header-entries (gr fn s)
  (let ((i (gensym)))
    `(dotimes (,i (funcall ,fn ,gr))
       (csv-header-entry ,s ,i))))

(defmacro csv-line-entry (gr acc i)
  `(format t "\"~A\"," (car (aref (funcall ,acc ,gr) ,i))))

(defmacro csv-line-entries (gr count-fn acc)
  (let ((i (gensym)))
    `(dotimes (,i (funcall ,count-fn ,gr))
       (csv-line-entry ,gr ,acc ,i))))

(defun produce-csv-arr (arr &rest body)
  ;; Header line
  (format t ",")
  (dolist (i body)
    (destructuring-bind (count-fn acc s) i
      (declare (ignore acc))
      (csv-header-entries (aref arr 0) count-fn s)))
  (format t "~%")
  ;; Then the rest of the lines
  (dotimes (i (length arr))
    (let ((gr (aref arr i)))
      (format t "\"~A\"," (grade-record-name gr))
      (dolist (j body)
	(destructuring-bind (count-fn acc s) j
	  (declare (ignore s))
	  (csv-line-entries gr count-fn acc)))
      (format t "~%"))))

(defun dump-csv (&rest arrl)
  (dolist (arr arrl)
    (produce-csv-arr arr 
		     `(,#'grade-record-num-exams ,#'grade-record-exams "\"Exam ~A\",")
		     `(,#'grade-record-num-quizzes ,#'grade-record-quiz "\"Quiz ~A\",")
		     `(,#'grade-record-num-hw ,#'grade-record-hw "\"Homework ~A\",")
		     `(,#'grade-record-num-lec-quizzes ,#'grade-record-lec-quizzes "\"Lecture quiz ~A\",")
		     `(,#'grade-record-num-group-work ,#'grade-record-group-work "\"Group work ~A\",")
		     )))
